import pygame
import sys
import math
import random
import os 

# ------------------------------------
# éŠæˆ²å…¨å±€å¸¸é‡
# ------------------------------------
SCREEN_WIDTH = 600
SCREEN_HEIGHT = 800
FPS = 60

# æ³¡æ³¡è¨­å®š
BUBBLE_RADIUS = 20
BUBBLE_DIAMETER = BUBBLE_RADIUS * 2
ROWS = 15 
COLS = 15 
PUSH_FREQUENCY = 5 
GRAVITY = 0.5    

# é¡è‰²èˆ‡ç‰¹æ®Šæ³¡æ³¡å®šç¾©
COLOR_OPTIONS = [
    (255, 69, 0),     # äº®æ©™ç´…
    (50, 205, 50),    # èŠå§†ç¶ 
    (30, 144, 255),  # å¯¶çŸ³è—
    (255, 255, 51),  # éœ“è™¹é»ƒ
    (255, 20, 147),  # æ·±ç²‰ç´…
    (0, 255, 255)    # é’è‰²/æ°´è—
]
# ç‰¹æ®Šæ³¡æ³¡é¡è‰²èª¿æ•´
BOMB_COLOR = (200, 200, 200)    # ç‚¸å½ˆåŸºè‰²
RAINBOW_COLOR = (255, 105, 180) # å½©è™¹åŸºè‰²
SHIFTER_COLOR = (255, 255, 0)   # è®Šè‰²é»ƒ (ç”¨æ–¼åˆå§‹æ¨™è¨˜)

SPECIAL_COLORS = [BOMB_COLOR, RAINBOW_COLOR, SHIFTER_COLOR] 

WHITE = (255, 255, 255)
BLACK = (0, 0, 0)
GRAY = (150, 150, 150)
RED = (200, 50, 50)
BLUE = (50, 50, 200)

# é“å…·å®šç¾©
POWER_UP_TYPES = {
    "BOMB": ((255, 100, 0), "B"),    
    "HAMMER": ((0, 100, 255), "H")    
}
POWER_UP_AREA_Y = SCREEN_HEIGHT - 120 

# éŠæˆ²ç‹€æ…‹æ©Ÿ
class GameState:
    MENU = 0
    PLAYING = 1
    PAUSED = 2
    GAMEOVER = 3

# ------------------------------------
# PowerUp é¡åˆ¥
# ------------------------------------
class PowerUp:
    def __init__(self, type_name, pos_index, font):
        self.type = type_name
        self.color, self.label = POWER_UP_TYPES[type_name] 
        self.font = font
        
        self.pos_index = pos_index 
        
        # åˆå§‹çŸ©å½¢ (å°‡åœ¨ setup_power_ups ä¸­è¢«è¦†è“‹)
        x = SCREEN_WIDTH // 2 - 100 + pos_index * 60
        self.rect = pygame.Rect(x, POWER_UP_AREA_Y, 50, 50)
        self.center = self.rect.center

    def draw(self, screen):
        """ç¹ªè£½é“å…·æŒ‰éˆ• (å½©è‰²æ–¹å¡Šå’Œæ–‡å­—)"""
        # ç¹ªè£½å¤–æ¡† (ç‚ºäº†è®“æ•¸é‡é¡¯ç¤ºæ›´æ¸…æ™°)
        pygame.draw.rect(screen, self.color, self.rect, border_radius=5)
        
        label_surf = self.font.render(self.label, True, WHITE)
        label_rect = label_surf.get_rect(center=self.center)
        screen.blit(label_surf, label_rect)

# ------------------------------------
# Bubble é¡åˆ¥
# ------------------------------------
class Bubble(pygame.sprite.Sprite):
    def __init__(self, color, row, col, is_static=False):
        super().__init__()
        self.color = color
        self.row = row
        self.col = col
        self.is_static = is_static
        self.is_falling = False  
        self.gravity = GRAVITY     
        self.fall_speed = 0        
        
        self.is_bomb = (color == BOMB_COLOR)
        self.is_rainbow = (color == RAINBOW_COLOR)
        self.is_shifter = (color == SHIFTER_COLOR)
        self.shifter_timer = 0 
        
        self.rect = pygame.Rect(0, 0, BUBBLE_DIAMETER, BUBBLE_DIAMETER)
        self.vel_x = 0
        self.vel_y = 0
        self.update_position()

    def update_position(self):
        """è¨ˆç®—æ³¡æ³¡çš„åƒç´ ä½ç½® (å¯¦ç¾èœ‚å·¢ç‹€ç¶²æ ¼)"""
        x_offset = 0 if self.row % 2 == 0 else BUBBLE_RADIUS 
        x = self.col * BUBBLE_DIAMETER + x_offset + BUBBLE_RADIUS
        y = self.row * int(BUBBLE_DIAMETER * 0.866) + BUBBLE_RADIUS 
        self.rect.center = (x, y)
        self.center = self.rect.center

    def draw(self, screen):
        """åœ¨è¢å¹•ä¸Šç¹ªè£½æ³¡æ³¡ï¼ŒåŒ…å«å…‰å½±æ•ˆæœ"""
        
        # 1. ç¹ªè£½ä¸»é«” (åœ“å½¢)
        draw_color = self.color
        if self.is_shifter:
             # è®“è®Šè‰²æ³¡æ³¡åœ¨å¹¾ç¨®é¡è‰²é–“å¿«é€Ÿåˆ‡æ›
            time_ms = pygame.time.get_ticks()
            current_index = (time_ms // 100) % len(COLOR_OPTIONS)
            draw_color = COLOR_OPTIONS[current_index]
            
        pygame.draw.circle(screen, draw_color, self.center, BUBBLE_RADIUS)
        
        # 2. ç¹ªè£½å…‰å½±æ•ˆæœ (ç«‹é«”æ„Ÿ)
        highlight_color = WHITE
        highlight_radius = BUBBLE_RADIUS // 2
        highlight_center = (self.center[0] - BUBBLE_RADIUS // 3, self.center[1] - BUBBLE_RADIUS // 3)
        
        pygame.draw.circle(screen, highlight_color, highlight_center, highlight_radius, 0)
        pygame.draw.circle(screen, WHITE, highlight_center, BUBBLE_RADIUS // 5, 0)

        
        # 3. ç¹ªè£½ç‰¹æ®Šæ¨™è¨˜
        if self.is_bomb:
            pygame.draw.line(screen, BLACK, (self.center[0] - 10, self.center[1] - 10), (self.center[0] + 10, self.center[1] + 10), 3)
            pygame.draw.line(screen, BLACK, (self.center[0] + 10, self.center[1] - 10), (self.center[0] - 10, self.center[1] + 10), 3)
        elif self.is_rainbow:
            pygame.draw.circle(screen, WHITE, self.center, BUBBLE_RADIUS // 3)
        elif self.is_shifter:
            font = pygame.font.SysFont('Arial', BUBBLE_RADIUS + 5, bold=True)
            text_surf = font.render("?", True, BLACK)
            text_rect = text_surf.get_rect(center=self.center)
            screen.blit(text_surf, text_rect)

# ------------------------------------
# Game é¡åˆ¥ï¼šéŠæˆ²ä¸»é‚è¼¯
# ------------------------------------
class Game:
    def __init__(self):
        # 1. åˆå§‹åŒ– Pygame æ¨¡çµ„ 
        pygame.init()
        
        self.screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
        pygame.display.set_caption("Pygame Bubble Shooter")
        self.clock = pygame.time.Clock()
        
        # 2. å­—é«”å®šç¾©
        self.score_font = pygame.font.SysFont('Arial', 24)
        self.title_font = pygame.font.SysFont('Arial', 48, bold=True)
        self.button_font = pygame.font.SysFont('Arial', 32)
        
        # â­ 2.5 èƒŒæ™¯éŸ³æ¨‚è¼‰å…¥
        pygame.mixer.init()
        self.background_music = None
        try:
            # è¼‰å…¥èƒŒæ™¯éŸ³æ¨‚ (è«‹æ›¿æ›ç‚ºæ‚¨å¯¦éš›çš„éŸ³æ¨‚æª”åï¼Œä¾‹å¦‚ 'bgm.mp3' æˆ– 'music.ogg')
            # å‡è¨­æª”åç‚º 'bgm.mp3'
            pygame.mixer.music.load('bgm.mp3') 
            self.background_music = True # æ¨™è¨˜ç‚ºè¼‰å…¥æˆåŠŸ
        except pygame.error as e:
            print(f"è­¦å‘Šï¼šèƒŒæ™¯éŸ³æ¨‚æª”æ¡ˆè¼‰å…¥å¤±æ•—ã€‚è«‹ç¢ºèª 'bgm.mp3' æª”æ¡ˆå­˜åœ¨ã€‚éŒ¯èª¤: {e}")
            self.background_music = False


        # 3. éŠæˆ²ç‹€æ…‹ç®¡ç†
        self.current_state = GameState.MENU
        
        # 4. éŠæˆ²ç‹€æ…‹è®Šæ•¸
        self.score = 0 
        self.shots_since_push = 0 
        self.running = True
        
        # æ™‚é™æ¨¡å¼è®Šæ•¸
        self.GAME_TIME_LIMIT = 120 
        self.time_left = self.GAME_TIME_LIMIT
        self.last_time_check = pygame.time.get_ticks()

        # é“å…·ç®¡ç†
        self.INITIAL_POWER_UP_COUNT = 2 
        self.power_up_counts = {"BOMB": self.INITIAL_POWER_UP_COUNT, "HAMMER": self.INITIAL_POWER_UP_COUNT} 
        self.power_up_objects = [] 
        self.hammer_mode = False 
        
        # é“å…·é€šçŸ¥ç®¡ç†
        self.notification_text = None
        self.notification_timer = 0
        
        # 5. éŠæˆ²åˆå§‹åŒ–
        self.reset_game()

    def reset_game(self):
        """é‡ç½®æ‰€æœ‰éŠæˆ²ç‹€æ…‹è®Šæ•¸ï¼Œæº–å‚™é–‹å§‹æ–°éŠæˆ²"""
        self.grid = [] 
        self.shooter_bubble = None 
        self.next_bubble_color = None 
        self.is_shooting = False
        self.score = 0 
        self.shots_since_push = 0 
        self.falling_bubbles = [] 
        self.time_left = self.GAME_TIME_LIMIT
        self.last_time_check = pygame.time.get_ticks()
        
        # é‡ç½®é“å…·
        self.power_up_counts = {"BOMB": self.INITIAL_POWER_UP_COUNT, "HAMMER": self.INITIAL_POWER_UP_COUNT} 
        self.hammer_mode = False
        
        # é‡ç½®é€šçŸ¥
        self.notification_text = None
        
        self.setup_power_ups()
        self.setup_grid()
        self.new_shooter_bubble()

    def setup_power_ups(self):
        """åˆå§‹åŒ–é“å…·æ¬„ä½ä¸¦è¨­å®šå·¦å³æ’ç‰ˆ"""
        self.power_up_objects = []
        
        # é“å…·å·¦å³ä½ˆå±€çš„ä½ç½®ä¸­å¿ƒé»
        positions = {
            "BOMB": SCREEN_WIDTH // 2 - 150,    
            "HAMMER": SCREEN_WIDTH // 2 + 100   
        }
        
        for type_name in ["BOMB", "HAMMER"]:
            x = positions[type_name]
            y = POWER_UP_AREA_Y
            rect = pygame.Rect(x, y, 50, 50)
            
            # å‰µå»º PowerUp å¯¦ä¾‹ä¸¦è¦†è“‹ä½ç½®
            power_up = PowerUp(type_name, 0, self.score_font) 
            power_up.rect = rect
            power_up.center = rect.center
            self.power_up_objects.append(power_up)

    def setup_grid(self):
        """åˆå§‹åŒ–ç¶²æ ¼æ³¡æ³¡ï¼Œä¸¦éš¨æ©Ÿç”Ÿæˆç‰¹æ®Šæ³¡æ³¡"""
        for r in range(ROWS):
            row_list = []
            for c in range(COLS):
                if r < 5: 
                    if r % 2 != 0 and c == COLS - 1:
                        bubble = None
                    else:
                        rand = random.random()
                        # éš¨æ©Ÿç”Ÿæˆç‰¹æ®Šæ³¡æ³¡
                        if rand < 0.02: 
                             color = BOMB_COLOR
                        elif rand < 0.04:
                             color = RAINBOW_COLOR
                        elif rand < 0.06: 
                             color = SHIFTER_COLOR
                        else:
                            color = random.choice(COLOR_OPTIONS[:4])
                            
                        bubble = Bubble(color, r, c, is_static=True)
                else:
                    bubble = None
                row_list.append(bubble)
            self.grid.append(row_list)
            
    def new_shooter_bubble(self):
        """ç”Ÿæˆæ–°çš„ç™¼å°„æ³¡æ³¡ä¸¦æ›´æ–°ä¸‹ä¸€å€‹æ³¡æ³¡çš„é¡è‰²"""
        if self.next_bubble_color is None:
            self.next_bubble_color = random.choice(COLOR_OPTIONS)
        
        color = self.next_bubble_color
        
        self.shooter_bubble = Bubble(color, -1, -1) 
        self.shooter_bubble.rect.center = (SCREEN_WIDTH // 2, SCREEN_HEIGHT - 50)
        self.shooter_bubble.center = self.shooter_bubble.rect.center
        
        # ä¸‹ä¸€å€‹æ³¡æ³¡æœ‰å°æ©Ÿç‡ç‚ºç‰¹æ®Šæ³¡æ³¡ (ç™¼å°„å€ä¸ç”Ÿæˆè®Šè‰²)
        rand = random.random()
        if rand < 0.03:
            self.next_bubble_color = random.choice([BOMB_COLOR, RAINBOW_COLOR])
        else:
            self.next_bubble_color = random.choice(COLOR_OPTIONS)

    def swap_bubbles(self):
        """äº¤æ›ç•¶å‰ç™¼å°„æ³¡æ³¡å’Œä¸‹ä¸€å€‹é è¦½æ³¡æ³¡çš„é¡è‰²"""
        if not self.is_shooting and self.shooter_bubble and self.next_bubble_color:
            current_color = self.shooter_bubble.color
            self.shooter_bubble.color = self.next_bubble_color
            self.next_bubble_color = current_color
            
            # æ›´æ–°å±¬æ€§æ——å¹Ÿ
            self.shooter_bubble.is_bomb = (self.shooter_bubble.color == BOMB_COLOR)
            self.shooter_bubble.is_rainbow = (self.shooter_bubble.color == RAINBOW_COLOR)
            self.shooter_bubble.is_shifter = False 

    def get_neighbors(self, r, c):
        """è¿”å›çµ¦å®š (r, c) æ³¡æ³¡çš„å…­å€‹é„°è¿‘ç¶²æ ¼åº§æ¨™ (èœ‚å·¢ç‹€é‚è¼¯)"""
        neighbors = []
        is_odd = r % 2 != 0

        neighbors.append((r - 1, c))    # ä¸Š
        neighbors.append((r + 1, c))    # ä¸‹
        neighbors.append((r, c - 1))    # å·¦
        neighbors.append((r, c + 1))    # å³

        if is_odd:
            neighbors.append((r - 1, c + 1)) # å³ä¸Š
            neighbors.append((r + 1, c + 1)) # å³ä¸‹
        else:
            neighbors.append((r - 1, c - 1)) # å·¦ä¸Š
            neighbors.append((r + 1, c - 1)) # å·¦ä¸‹
            
        return neighbors

    def get_nearest_grid_position(self, x, y):
        """è¨ˆç®—çµ¦å®šåƒç´ åº§æ¨™ (x, y) æœ€æ¥è¿‘çš„ç¶²æ ¼ (row, col) ä½ç½®"""
        r = int(y / (BUBBLE_DIAMETER * 0.866))
        r = max(0, min(ROWS - 1, r))

        x_offset = BUBBLE_RADIUS if r % 2 != 0 else 0
        
        c = int((x - x_offset) / BUBBLE_DIAMETER)
        c = max(0, min(COLS - 1, c))

        return r, c

    def check_for_matches(self, r, c, target_color):
        """ä½¿ç”¨ BFS æŸ¥æ‰¾æ‰€æœ‰é€£æ¥çš„åŒè‰²æ³¡æ³¡ (è€ƒæ…®å½©è™¹æ³¡æ³¡å’Œè®Šè‰²æ³¡æ³¡)"""
        if self.grid[r][c] is None:
            return []
            
        queue = [(r, c)]
        visited = set([(r, c)])
        matched_bubbles = []

        while queue:
            curr_r, curr_c = queue.pop(0)
            matched_bubbles.append((curr_r, curr_c))

            for next_r, next_c in self.get_neighbors(curr_r, curr_c):
                if 0 <= next_r < ROWS and 0 <= next_c < COLS:
                    neighbor = self.grid[next_r][next_c]
                    
                    if neighbor and (next_r, next_c) not in visited:
                        # åŒ¹é…é‚è¼¯ï¼šé¡è‰²åŒ¹é… æˆ– é„°å±…æ˜¯å½©è™¹æ³¡æ³¡ æˆ– é„°å±…æ˜¯è®Šè‰²æ³¡æ³¡
                        is_match = (neighbor.color == target_color or neighbor.is_rainbow or neighbor.is_shifter)
                        
                        if is_match:
                            visited.add((next_r, next_c))
                            queue.append((next_r, next_c))
                        
        return matched_bubbles
    
    def trigger_bomb(self, r, c):
        """æ¶ˆé™¤ç‚¸å½ˆæ³¡æ³¡åŠå…¶å‘¨åœçš„æ‰€æœ‰é„°å±…"""
        
        bubbles_to_clear = set([(r, c)])
        
        for r_n, c_n in self.get_neighbors(r, c):
            if 0 <= r_n < ROWS and 0 <= c_n < COLS and self.grid[r_n][c_n]:
                bubbles_to_clear.add((r_n, c_n))
                
        cleared_any = False
        for r_clear, c_clear in bubbles_to_clear:
            bubble = self.grid[r_clear][c_clear]
            if bubble:
                bubble.is_falling = True
                bubble.is_static = False
                self.falling_bubbles.append(bubble)
                self.grid[r_clear][c_clear] = None
                self.score += 20 
                cleared_any = True
                
        if cleared_any:
            # ç‚¸å½ˆå¼•èµ·çš„æ‰è½
            self.check_for_floating_bubbles()

    def spawn_power_up(self, power_up_type):
        """çµ¦äºˆæŒ‡å®šé“å…·ï¼Œä¸¦åœ¨è¢å¹•ä¸Šé¡¯ç¤ºé€šçŸ¥"""
        self.power_up_counts[power_up_type] += 1
        self.setup_power_ups() 
        
        # è¨­ç½®è¢å¹•ä¸­å¤®é€šçŸ¥
        self.notification_text = f"ğŸ‰ æ­å–œç²å¾— {power_up_type} é“å…·ï¼"
        self.notification_timer = pygame.time.get_ticks() 
        
        print(f"ğŸ‰ ç²å¾— {power_up_type} é“å…·ï¼ç•¶å‰æ•¸é‡: {self.power_up_counts[power_up_type]}")

    def clear_matches(self, matches):
        """å¾ç¶²æ ¼ä¸­ç§»é™¤åŒ¹é…çš„æ³¡æ³¡ï¼Œä¸¦è§¸ç™¼æ‰è½å‹•ç•«"""
        
        if len(matches) >= 3:
            cleared_count = 0
            
            for r, c in matches:
                bubble = self.grid[r][c]
                if bubble: 
                    bubble.is_falling = True
                    bubble.is_static = False
                    self.falling_bubbles.append(bubble)
                    self.grid[r][c] = None 
                    cleared_count += 1
            
            self.score += cleared_count * 10 
            
            # ã€é“å…·æ‰è½åˆ¤æ–·ã€‘
            if cleared_count >= 5 and random.random() < 0.20:
                power_up_type = random.choice(["BOMB", "HAMMER"]) 
                self.spawn_power_up(power_up_type)
            
            return cleared_count > 0 
        return False

    def check_for_floating_bubbles(self):
        """æª¢æŸ¥ä¸¦æ¶ˆé™¤æœªé€£æ¥åˆ°é ‚éƒ¨é‚Šç•Œçš„æ‡¸æ›æ³¡æ³¡ (æ‰è½å¾—åˆ†)"""
        visited = set()
        queue = []
        for c in range(COLS):
            if self.grid[0][c] is not None:
                queue.append((0, c))
                visited.add((0, c))
        
        while queue:
            curr_r, curr_c = queue.pop(0)
            for next_r, next_c in self.get_neighbors(curr_r, curr_c):
                if 0 <= next_r < ROWS and 0 <= next_c < COLS and (next_r, next_c) not in visited:
                    neighbor = self.grid[next_r][next_c]
                    if neighbor:
                        visited.add((next_r, next_c))
                        queue.append((next_r, next_c))
                        
        dropped_count = 0
        for r in range(ROWS):
            for c in range(COLS):
                if self.grid[r][c] is not None and (r, c) not in visited:
                    bubble = self.grid[r][c]
                    bubble.is_falling = True
                    bubble.is_static = False
                    self.falling_bubbles.append(bubble)
                    self.grid[r][c] = None 
                    dropped_count += 1
        
        if dropped_count > 0:
            self.score += dropped_count * 50

    def push_new_row(self):
        """å°‡æ‰€æœ‰æ³¡æ³¡å‘ä¸‹æ¨å‹•ä¸€è¡Œï¼Œä¸¦åœ¨é ‚éƒ¨æ–°å¢ä¸€æ’éš¨æ©Ÿæ³¡æ³¡"""
        last_grid_row_index = ROWS - 1
        # æª¢æŸ¥éŠæˆ²æ˜¯å¦çµæŸ
        for c in range(COLS):
            if self.grid[last_grid_row_index - 1][c] is not None:
                 print("éŠæˆ²çµæŸï¼šæ³¡æ³¡åˆ°é”åº•éƒ¨ç™¼å°„å€ï¼")
                 self.current_state = GameState.GAMEOVER 
                 return

        # å‘ä¸‹æ¨å‹•
        for r in range(ROWS - 1, 0, -1):
            for c in range(COLS):
                if self.grid[r-1][c] is not None:
                    self.grid[r-1][c].row = r
                    self.grid[r-1][c].update_position()
                self.grid[r][c] = self.grid[r-1][c]

        # ç”Ÿæˆæ–°çš„ä¸€è¡Œ
        new_row = []
        possible_colors = [b.color for r_list in self.grid for b in r_list if b]
        if not possible_colors:
             possible_colors = COLOR_OPTIONS[:4] 
        
        for c in range(COLS):
            rand = random.random()
            if rand < 0.02: 
                 color = BOMB_COLOR
            elif rand < 0.04:
                 color = RAINBOW_COLOR
            elif rand < 0.06:
                 color = SHIFTER_COLOR
            else:
                color = random.choice(possible_colors)
            
            new_bubble = Bubble(color, 0, c, is_static=True)
            new_row.append(new_bubble)
            
        self.grid[0] = new_row
        
    # --- é“å…·å‡½æ•¸ ---
    def activate_power_up(self, type_name):
        """æ ¹æ“šé¡å‹å•Ÿå‹•é“å…·æ•ˆæœ"""
        if self.power_up_counts[type_name] > 0:
            if type_name == "BOMB":
                self.use_bomb_power_up()
                self.power_up_counts["BOMB"] -= 1
                
            elif type_name == "HAMMER":
                self.hammer_mode = True
                
            self.setup_power_ups() # æ›´æ–°é¡¯ç¤º

    def use_bomb_power_up(self, radius=3):
        """ä½¿ç”¨é“å…·ï¼šæ¶ˆé™¤ç¶²æ ¼ä¸­å¤®å€åŸŸçš„æ³¡æ³¡"""
        center_r, center_c = ROWS // 3, COLS // 2 
        
        cells_to_clear = set()
        for r_offset in range(-radius, radius + 1):
            for c_offset in range(-radius, radius + 1):
                r = center_r + r_offset
                c = center_c + c_offset
                if 0 <= r < ROWS and 0 <= c < COLS:
                    cells_to_clear.add((r, c))

        cleared_any = False
        for r, c in cells_to_clear:
            bubble = self.grid[r][c]
            if bubble:
                bubble.is_falling = True
                bubble.is_static = False
                self.falling_bubbles.append(bubble)
                self.grid[r][c] = None
                self.score += 50
                cleared_any = True
                
        if cleared_any:
            self.check_for_floating_bubbles()

    def use_hammer(self, r, c):
        """ä½¿ç”¨é“å…·ï¼šç§»é™¤æŒ‡å®šå–®å€‹æ³¡æ³¡"""
        if self.power_up_counts["HAMMER"] > 0:
            bubble = self.grid[r][c]
            if bubble:
                bubble.is_falling = True
                bubble.is_static = False
                self.falling_bubbles.append(bubble)
                self.grid[r][c] = None
                
                self.score += 30 
                
                self.check_for_floating_bubbles()
            
            self.power_up_counts["HAMMER"] -= 1
            self.hammer_mode = False
            self.setup_power_ups()
    
    # --- è¼¸å…¥è™•ç† ---
    def handle_input(self):
        """è™•ç†æ‰€æœ‰éŠæˆ²ç‹€æ…‹ä¸‹çš„æ»‘é¼ å’Œéµç›¤è¼¸å…¥"""
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                self.running = False
            
            # --- è™•ç†éµç›¤è¼¸å…¥ ---
            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_SPACE and self.current_state == GameState.PLAYING:
                    self.swap_bubbles()
                elif event.key == pygame.K_p and self.current_state == GameState.PLAYING:
                    self.current_state = GameState.PAUSED
                elif event.key == pygame.K_p and self.current_state == GameState.PAUSED:
                    self.current_state = GameState.PLAYING
            
            # --- è™•ç†æ»‘é¼ é»æ“Š (åœ¨ MENU/GAMEOVER/PLAYING ç‹€æ…‹ä¸‹) ---
            if event.type == pygame.MOUSEBUTTONDOWN:
                mouse_x, mouse_y = pygame.mouse.get_pos()
                
                if self.current_state == GameState.MENU:
                    self.handle_menu_click(mouse_x, mouse_y)
                elif self.current_state == GameState.GAMEOVER:
                    self.handle_gameover_click(mouse_x, mouse_y)
                elif self.current_state == GameState.PLAYING:
                    self.handle_playing_click(mouse_x, mouse_y)

    def handle_menu_click(self, x, y):
        """è™•ç†ä¸»é¸å–®æŒ‰éˆ•é»æ“Š"""
        start_button_rect = pygame.Rect(SCREEN_WIDTH // 2 - 100, SCREEN_HEIGHT // 2 - 50, 200, 60)
        quit_button_rect = pygame.Rect(SCREEN_WIDTH // 2 - 100, SCREEN_HEIGHT // 2 + 50, 200, 60)
        
        if start_button_rect.collidepoint(x, y):
            self.current_state = GameState.PLAYING
            self.reset_game() 
        elif quit_button_rect.collidepoint(x, y):
            self.running = False

    def handle_gameover_click(self, x, y):
        """è™•ç†éŠæˆ²çµæŸæŒ‰éˆ•é»æ“Š"""
        restart_button_rect = pygame.Rect(SCREEN_WIDTH // 2 - 100, SCREEN_HEIGHT // 2 + 50, 200, 60)
        
        if restart_button_rect.collidepoint(x, y):
            self.current_state = GameState.MENU 

    def handle_playing_click(self, x, y):
        """è™•ç†éŠæˆ²é€²è¡Œä¸­çš„é»æ“Šé‚è¼¯ (ç™¼å°„ã€é“å…·)"""
        
        # è™•ç†éŒ˜å­æ¨¡å¼ä¸‹çš„é»æ“Š
        if self.hammer_mode:
            r, c = self.get_nearest_grid_position(x, y)
            if 0 <= r < ROWS and 0 <= c < COLS and self.grid[r][c] is not None:
                self.use_hammer(r, c)
                return
        
        # æª¢æŸ¥æ˜¯å¦é»æ“Šäº†é“å…·æŒ‰éˆ•
        clicked_power_up = False
        for pu_obj in self.power_up_objects:
            if pu_obj.rect.collidepoint(x, y):
                self.activate_power_up(pu_obj.type)
                clicked_power_up = True
                break
        
        if clicked_power_up:
            return

        # è™•ç†ç™¼å°„æ³¡æ³¡
        if y < POWER_UP_AREA_Y and not self.is_shooting and not self.hammer_mode:
            start_x, start_y = self.shooter_bubble.center
            dx = x - start_x
            dy = y - start_y
            
            if dy < 0:
                dist = math.sqrt(dx**2 + dy**2)
                speed = 15
                self.shooter_bubble.vel_x = (dx / dist) * speed
                self.shooter_bubble.vel_y = (dy / dist) * speed
                self.is_shooting = True
                    
    # --- æ›´æ–°å’Œç¢°æ’ ---          
    def update(self):
        """æ›´æ–°éŠæˆ²ç‹€æ…‹ï¼ŒåŒ…å«ç™¼å°„ã€ç¢°æ’ã€æ‰è½å‹•ç•«å’Œè¨ˆæ™‚å™¨"""
        
        if self.current_state != GameState.PLAYING: 
            return 
            
        # è¨ˆæ™‚å™¨é‚è¼¯
        current_time = pygame.time.get_ticks()
        time_elapsed = (current_time - self.last_time_check) / 1000.0
        self.last_time_check = current_time
        
        self.time_left -= time_elapsed
        
        if self.time_left <= 0:
            self.time_left = 0
            self.current_state = GameState.GAMEOVER 
            print(f"æ™‚é–“åˆ°ï¼éŠæˆ²çµæŸã€‚æœ€çµ‚åˆ†æ•¸: {self.score}")
            return
            
        # è®Šè‰²æ³¡æ³¡é‚è¼¯
        for r in range(ROWS):
            for c in range(COLS):
                bubble = self.grid[r][c]
                if bubble and bubble.is_shifter:
                    # æ¯ 100 å¹€ï¼ˆç´„ 1.6 ç§’ï¼‰è®Šä¸€æ¬¡è‰²
                    if bubble.shifter_timer >= 100: 
                        # è®Šæ›æˆå ´ä¸Šå·²æœ‰çš„éš¨æ©Ÿé¡è‰² (æ’é™¤ç‰¹æ®Šè‰²)
                        possible_colors = [b.color for r_list in self.grid for b in r_list if b and b.color not in SPECIAL_COLORS]
                        if possible_colors:
                            bubble.color = random.choice(possible_colors)
                        else:
                             bubble.color = random.choice(COLOR_OPTIONS)
                        bubble.shifter_timer = 0
                    else:
                        bubble.shifter_timer += 1
                        
        # æ³¡æ³¡ç™¼å°„/ç§»å‹•é‚è¼¯
        if self.is_shooting:
            self.shooter_bubble.rect.x += self.shooter_bubble.vel_x
            self.shooter_bubble.rect.y += self.shooter_bubble.vel_y
            self.shooter_bubble.center = self.shooter_bubble.rect.center
            
            # ç‰†å£åå½ˆ
            if self.shooter_bubble.rect.left <= 0 or self.shooter_bubble.rect.right >= SCREEN_WIDTH:
                self.shooter_bubble.vel_x *= -1 
            # æ’åˆ°é ‚éƒ¨
            if self.shooter_bubble.rect.top <= BUBBLE_RADIUS:
                self.is_shooting = False
                self.handle_collision(self.shooter_bubble, hit_top=True)
                return 

            # ç¶²æ ¼ç¢°æ’æª¢æŸ¥
            for r in range(ROWS):
                for c in range(COLS):
                    target_bubble = self.grid[r][c]
                    if target_bubble:
                        distance = math.sqrt(
                            (self.shooter_bubble.center[0] - target_bubble.center[0])**2 +
                            (self.shooter_bubble.center[1] - target_bubble.center[1])**2
                        )
                        # ç¢°æ’è·é›¢æª¢æŸ¥
                        if distance < BUBBLE_DIAMETER - 1:
                            self.is_shooting = False
                            self.handle_collision(self.shooter_bubble, target_bubble=target_bubble)
                            return
        
        # æ‰è½æ³¡æ³¡å‹•ç•«æ›´æ–°
        new_falling_bubbles = []
        for bubble in self.falling_bubbles:
            bubble.fall_speed += bubble.gravity
            bubble.rect.y += bubble.fall_speed
            bubble.center = bubble.rect.center
            
            if bubble.rect.top < SCREEN_HEIGHT:
                new_falling_bubbles.append(bubble)
        
        self.falling_bubbles = new_falling_bubbles 
                            
    def handle_collision(self, bubble, hit_top=False, target_bubble=None):
        """è™•ç†ç™¼å°„æ³¡æ³¡çš„å›ºå®šã€ç‰¹æ®Šæ³¡æ³¡è§¸ç™¼ã€åŒ¹é…å’Œæ¶ˆé™¤"""
        
        # --- 1. è¨ˆç®—æœ€ä½³é™„è‘—ç¶²æ ¼ä½ç½® (ç•¥) ---
        if target_bubble:
            r_target, c_target = target_bubble.row, target_bubble.col
            best_r, best_c = -1, -1
            min_dist_sq = float('inf')

            # æª¢æŸ¥ç›®æ¨™æ³¡æ³¡å‘¨åœçš„æ‰€æœ‰ç©ºé„°å±…
            for r_n, c_n in self.get_neighbors(r_target, c_target):
                if 0 <= r_n < ROWS and 0 <= c_n < COLS and self.grid[r_n][c_n] is None:
                    temp_bubble = Bubble(WHITE, r_n, c_n, is_static=False)
                    center_x, center_y = temp_bubble.center
                    dist_sq = (bubble.center[0] - center_x)**2 + (bubble.center[1] - center_y)**2
                    
                    if dist_sq < min_dist_sq:
                        min_dist_sq = dist_sq
                        best_r, best_c = r_n, c_n
            
            if best_r != -1:
                 r, c = best_r, best_c
            else:
                 r, c = self.get_nearest_grid_position(bubble.center[0], bubble.center[1])
        
        # --- 2. è¨ˆç®—é ‚éƒ¨é™„è‘—ä½ç½® ---
        elif hit_top:
            r, c = self.get_nearest_grid_position(bubble.center[0], BUBBLE_RADIUS + 1)
        else:
            self.new_shooter_bubble()
            return
            
        r = max(0, min(ROWS - 1, r))
        c = max(0, min(COLS - 1, c))
        
        # --- 3. è™•ç†å›ºå®šå’ŒåŒ¹é… ---
        if self.grid[r][c] is None:
            
            # 1. ç‚¸å½ˆæ³¡æ³¡è§¸ç™¼
            if bubble.is_bomb:
                self.trigger_bomb(r, c)
            
            # 2. æ™®é€š/å½©è™¹/è®Šè‰²æ³¡æ³¡å›ºå®š
            else:
                # å›ºå®šæ³¡æ³¡åˆ°ç¶²æ ¼
                bubble.row = r
                bubble.col = c
                bubble.is_static = True
                bubble.update_position() 
                self.grid[r][c] = bubble
                
                target_color = bubble.color
                
                # å½©è™¹æ³¡æ³¡é‚è¼¯
                if bubble.is_rainbow:
                    match_neighbor_color = None
                    for r_n, c_n in self.get_neighbors(r, c):
                        if 0 <= r_n < ROWS and 0 <= c_n < COLS and self.grid[r_n][c_n]:
                            neighbor = self.grid[r_n][c_n]
                            if not (neighbor.is_rainbow or neighbor.is_bomb or neighbor.is_shifter):
                                match_neighbor_color = neighbor.color
                                break
                    if match_neighbor_color:
                        target_color = match_neighbor_color
                        self.grid[r][c].color = target_color 
                    else:
                        pass 

                # åŒ¹é…æª¢æŸ¥
                matches = self.check_for_matches(r, c, target_color)
                if self.clear_matches(matches):
                    self.check_for_floating_bubbles()
            
            # æ¨æ“ è¨ˆæ•¸
            self.shots_since_push += 1
            if self.shots_since_push >= PUSH_FREQUENCY: 
                self.push_new_row()
                self.shots_since_push = 0
            
        self.new_shooter_bubble()


    def draw_procedural_background(self):
        """ç¹ªè£½å¾æ·±ç°è‰²åˆ°æ·ºç°è‰²/ç§‘æŠ€è—è‰²çš„é‡‘å±¬/é«˜ç§‘æŠ€æ¼¸è®ŠèƒŒæ™¯"""
        
        # å®šç¾©é‡‘å±¬é¢¨æ ¼çš„é¡è‰²ï¼š
        METAL_DARK = (20, 20, 30) 
        METAL_LIGHT = (70, 70, 100)  
        
        for y in range(SCREEN_HEIGHT):
            # è¨ˆç®—æ¼¸è®Šæ¯”ä¾‹
            ratio = y / SCREEN_HEIGHT
            
            # R, G, B åˆ†é‡ç¨ç«‹è¨ˆç®—æ¼¸è®Š (é ‚éƒ¨äº®ï¼Œåº•éƒ¨æš—)
            r = int(METAL_LIGHT[0] + (METAL_DARK[0] - METAL_LIGHT[0]) * ratio)
            g = int(METAL_LIGHT[1] + (METAL_DARK[1] - METAL_LIGHT[1]) * ratio)
            b = int(METAL_LIGHT[2] + (METAL_DARK[2] - METAL_LIGHT[2]) * ratio)
            
            color = (r, g, b)
            pygame.draw.line(self.screen, color, (0, y), (SCREEN_WIDTH, y))

    def draw_game_elements(self):
        """ç¹ªè£½æ‰€æœ‰éŠæˆ²ä¸­çš„å…ƒç´ """
        
        # ç¹ªè£½ç¶²æ ¼å’Œæ‰è½ä¸­çš„æ³¡æ³¡
        for r in range(ROWS):
            for c in range(COLS):
                if self.grid[r][c]:
                    self.grid[r][c].draw(self.screen)
        for bubble in self.falling_bubbles:
            bubble.draw(self.screen)
                    
        # ç¹ªè£½ç™¼å°„æ³¡æ³¡
        if self.shooter_bubble:
            self.shooter_bubble.draw(self.screen)

        # ç¹ªè£½ç™¼å°„æŒ‡ç¤ºå™¨ 
        if not self.is_shooting and not self.hammer_mode:
            mouse_x, mouse_y = pygame.mouse.get_pos()
            start_x, start_y = self.shooter_bubble.center
            
            if mouse_y < start_y:
                # ç¹ªè£½è¼”åŠ©ç„æº–ç·š
                pygame.draw.line(self.screen, WHITE, (start_x, start_y), (mouse_x, mouse_y), 2)
        
        # ç¹ªè£½ä¸‹ä¸€å€‹æ³¡æ³¡çš„é¡è‰²é è¦½
        next_pos = (SCREEN_WIDTH // 2 + 50, SCREEN_HEIGHT - 50)
        pygame.draw.circle(self.screen, WHITE, next_pos, BUBBLE_RADIUS // 2 + 5, 2)
        pygame.draw.circle(self.screen, self.next_bubble_color, next_pos, BUBBLE_RADIUS // 2)

        # ç¹ªè£½åˆ†æ•¸å’Œè¨ˆæ•¸
        score_text = self.score_font.render(f"Score: {self.score}", True, WHITE)
        self.screen.blit(score_text, (10, 10)) 
        push_text = self.score_font.render(f"Shots to Push: {PUSH_FREQUENCY - self.shots_since_push}", True, WHITE)
        self.screen.blit(push_text, (SCREEN_WIDTH - push_text.get_width() - 10, 10))
        
        # ç¹ªè£½è¨ˆæ™‚å™¨
        minutes = int(self.time_left) // 60
        seconds = int(self.time_left) % 60
        time_text = self.score_font.render(f"Time Left: {minutes:02d}:{seconds:02d}", True, WHITE)
        self.screen.blit(time_text, (SCREEN_WIDTH // 2 - time_text.get_width() // 2, 10))

        # ç¹ªè£½äº¤æ›æç¤º
        swap_text = self.score_font.render("SPACE to SWAP | P to PAUSE", True, WHITE)
        self.screen.blit(swap_text, (SCREEN_WIDTH // 2 - swap_text.get_width() // 2, SCREEN_HEIGHT - 20))

        # ç¹ªè£½é“å…·æ¬„ä½
        pygame.draw.line(self.screen, WHITE, (0, POWER_UP_AREA_Y - 10), (SCREEN_WIDTH, POWER_UP_AREA_Y - 10), 1)

        # é“å…·é¡¯ç¤ºå’Œæ•¸é‡
        for pu_obj in self.power_up_objects:
            pu_obj.draw(self.screen) 
            
            count = self.power_up_counts[pu_obj.type]
            count_surf = self.score_font.render(f"x{count}", True, WHITE)
            
            # æ ¹æ“šå·¦å³ä½ç½®èª¿æ•´æ•¸é‡æ–‡æœ¬ä½ç½®
            if pu_obj.type == "BOMB": # å·¦å´
                text_x = pu_obj.rect.right + 5
            else: # HAMMER å³å´
                text_x = pu_obj.rect.left - count_surf.get_width() - 5
                
            self.screen.blit(count_surf, (text_x, pu_obj.rect.centery - count_surf.get_height() // 2))

        # ç¹ªè£½éŒ˜å­æ¨¡å¼æŒ‡ç¤º
        if self.hammer_mode:
            hammer_text = self.score_font.render("HAMMER MODE: Click a bubble to REMOVE it.", True, (255, 255, 0))
            self.screen.blit(hammer_text, (SCREEN_WIDTH // 2 - hammer_text.get_width() // 2, POWER_UP_AREA_Y + 60))

        # ç¹ªè£½é“å…·ç²å¾—é€šçŸ¥ (2ç§’å¾Œè‡ªå‹•æ¶ˆå¤±)
        if self.notification_text:
            time_elapsed = pygame.time.get_ticks() - self.notification_timer
            if time_elapsed < 2000: # é¡¯ç¤º 2 ç§’
                # ä½¿ç”¨æ›´å¤§çš„å­—é«”ä¾†ç¢ºä¿é¡¯ç¤ºæ¸…æ™°
                notif_surf = self.title_font.render(self.notification_text, True, (255, 255, 0))
                notif_rect = notif_surf.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2))
                self.screen.blit(notif_surf, notif_rect)
            else:
                self.notification_text = None # 2 ç§’å¾Œæ¸…é™¤é€šçŸ¥


    def draw_button(self, text, rect, color, hover_color):
        """é€šç”¨æŒ‰éˆ•ç¹ªè£½å‡½æ•¸ (æ”¯æ´æ‡¸åœè®Šè‰²)"""
        mouse_pos = pygame.mouse.get_pos()
        current_color = hover_color if rect.collidepoint(mouse_pos) else color
        
        pygame.draw.rect(self.screen, current_color, rect, border_radius=10)
        
        text_surf = self.button_font.render(text, True, WHITE)
        text_rect = text_surf.get_rect(center=rect.center)
        self.screen.blit(text_surf, text_rect)
        
        return rect 

    def draw_menu_screen(self):
        """ç¹ªè£½ä¸»é¸å–®ç•«é¢"""
        self.draw_procedural_background()
        
        title_text = self.title_font.render("Bubble Shooter Game", True, WHITE)
        title_rect = title_text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 4))
        self.screen.blit(title_text, title_rect)
        
        # é–‹å§‹éŠæˆ²æŒ‰éˆ•
        start_rect = pygame.Rect(SCREEN_WIDTH // 2 - 100, SCREEN_HEIGHT // 2 - 50, 200, 60)
        self.draw_button("Start Game", start_rect, BLUE, (100, 100, 255))
        
        # é€€å‡ºéŠæˆ²æŒ‰éˆ•
        quit_rect = pygame.Rect(SCREEN_WIDTH // 2 - 100, SCREEN_HEIGHT // 2 + 50, 200, 60)
        self.draw_button("Quit Game", quit_rect, RED, (255, 100, 100))

    def draw_pause_screen(self):
        """ç¹ªè£½æš«åœç•«é¢"""
        s = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT))
        s.set_alpha(150) 
        s.fill(BLACK)
        self.screen.blit(s, (0, 0))
        
        pause_text = self.title_font.render("PAUSED", True, WHITE)
        text_rect = pause_text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 - 50))
        self.screen.blit(pause_text, text_rect)
        
        hint_text = self.score_font.render("Press P to continue", True, GRAY)
        hint_rect = hint_text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 + 20))
        self.screen.blit(hint_text, hint_rect)

    def draw_gameover_screen(self):
        """ç¹ªè£½éŠæˆ²çµæŸç•«é¢"""
        self.draw_procedural_background()
        
        gameover_text = self.title_font.render("GAME OVER", True, RED)
        go_rect = gameover_text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 4))
        self.screen.blit(gameover_text, go_rect)

        score_text = self.button_font.render(f"Final Score: {self.score}", True, WHITE)
        score_rect = score_text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 - 50))
        self.screen.blit(score_text, score_rect)
        
        restart_rect = pygame.Rect(SCREEN_WIDTH // 2 - 100, SCREEN_HEIGHT // 2 + 50, 200, 60)
        self.draw_button("Back to Menu", restart_rect, BLUE, (100, 100, 255))


    def draw(self):
        """æ ¹æ“šç•¶å‰ç‹€æ…‹ç¹ªè£½ç•«é¢"""
        
        self.screen.fill(BLACK) 
        
        if self.current_state == GameState.MENU:
            self.draw_menu_screen()
        
        elif self.current_state == GameState.PLAYING or self.current_state == GameState.PAUSED:
            self.draw_procedural_background()
            self.draw_game_elements()
            
            if self.current_state == GameState.PAUSED:
                self.draw_pause_screen()
                
        elif self.current_state == GameState.GAMEOVER:
            self.draw_gameover_screen()
            
        pygame.display.flip()
        
    def run(self):
        """éŠæˆ²ä¸»å¾ªç’°"""
        
        # å•Ÿå‹•èƒŒæ™¯éŸ³æ¨‚ (å¦‚æœè¼‰å…¥æˆåŠŸ)
        if self.background_music:
            # -1 ä»£è¡¨ç„¡é™å¾ªç’°æ’­æ”¾
            pygame.mixer.music.play(-1) 
            
        while self.running:
            self.handle_input()
            self.update()
            self.draw()
            self.clock.tick(FPS)
            
        pygame.quit()
        sys.exit()

# é‹è¡ŒéŠæˆ²
if __name__ == "__main__":
    game = Game()
    game.run()
