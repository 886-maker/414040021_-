import pygame
import sys
import math
import random
import os

# åˆå§‹åŒ–éŸ³é »æ¨¡çµ„
pygame.mixer.init()

# ------------------------------------
# 1. éŠæˆ²å…¨å±€å¸¸é‡èˆ‡è¨­å®š
# ------------------------------------
SCREEN_WIDTH = 600
SCREEN_HEIGHT = 800
FPS = 60

# æ³¡æ³¡èˆ‡ç¶²æ ¼è¨­å®š
BUBBLE_RADIUS = 20
BUBBLE_DIAMETER = BUBBLE_RADIUS * 2
ROWS = 15
COLS = 15
PUSH_FREQUENCY = 5
GRAVITY = 0.5
SHOOTER_Y = SCREEN_HEIGHT - 50 # ç™¼å°„å™¨ä¸­å¿ƒYåº§æ¨™

# èƒ½é‡èˆ‡é€Ÿåº¦å¸¸é‡
ENERGY_BAR_MAX = 200        # èƒ½é‡ç´¯ç©ä¸Šé™
SHOOT_SPEED = 15            # åŸºç¤å°„æ“Šé€Ÿåº¦
FAST_SHOOT_SPEED = 30       # å¿«é€Ÿæ¨¡å¼å°„æ“Šé€Ÿåº¦
FAST_MODE_DURATION = 5      # å¿«é€Ÿæ¨¡å¼æŒçºŒæ™‚é–“ (ç§’)
ENERGY_IMPACT_BUBBLE_SCORE = 10 # èƒ½é‡è¡æ“Šå–®å€‹æ³¡æ³¡å¾—åˆ†

# é¡è‰²å®šç¾© 
COLOR_OPTIONS = [
    (255, 69, 0),    # äº®æ©™ç´…
    (50, 205, 50),   # èŠå§†ç¶ 
    (30, 144, 255),  # å¯¶çŸ³è—
    (255, 255, 51),  # éœ“è™¹é»ƒ
    (255, 20, 147),  # æ·±ç²‰ç´…
    (0, 255, 255)    # é’è‰²/æ°´è—
]
# ç‰¹æ®Šæ³¡æ³¡é¡è‰²
BOMB_COLOR = (200, 200, 200)      # ç‚¸å½ˆ
RAINBOW_COLOR = (255, 105, 180)   # å½©è™¹
SHIFTER_COLOR = (255, 255, 0)     # è®Šè‰²ï¼ˆä½”ä½é¡è‰²ï¼‰
SPECIAL_COLORS = [BOMB_COLOR, RAINBOW_COLOR, SHIFTER_COLOR]

# é¡è‰²å¸¸é‡
ENERGY_COLOR = (255, 165, 0) 
HUD_BG_COLOR = (250, 250, 250, 180) 
FAST_MODE_COLOR = (0, 255, 0) 
WHITE = (255, 255, 255)
BLACK = (0, 0, 0) 
RED = (255, 0, 0)   
BLUE = (0, 0, 255)  

# é“å…·å®šç¾©
POWER_UP_TYPES = {
    "BOMB": ((255, 100, 0), "B"),
    "HAMMER": ((0, 100, 255), "H")
}
POWER_UP_AREA_Y = SCREEN_HEIGHT - 120

# éŠæˆ²ç‹€æ…‹æ©Ÿ
class GameState:
    MENU = 0
    PLAYING = 1
    PAUSED = 2
    GAMEOVER = 3

# ------------------------------------
# 2. PowerUp é¡åˆ¥ (é“å…·æ¬„ UI å…ƒç´ )
# ------------------------------------
class PowerUp:
    def __init__(self, type_name, rect, font, image=None): 
        super().__init__()
        self.type = type_name
        self.color, self.label = POWER_UP_TYPES[type_name]
        self.font = font
        self.rect = rect
        self.center = self.rect.center
        self.image = image

    def draw(self, screen, count):
        pygame.draw.rect(screen, self.color, self.rect, border_radius=5)
        
        if self.image:
            image_rect = self.image.get_rect(center=self.center)
            screen.blit(self.image, image_rect)
        else:
            label_surf = self.font.render(self.label, True, WHITE) 
            label_rect = label_surf.get_rect(center=self.center)
            screen.blit(label_surf, label_rect)

        count_color = BLACK 
        count_surf = self.font.render(f"x{count}", True, count_color) 
        
        if self.type == "BOMB":
            text_x = self.rect.right + 5
        else: 
            text_x = self.rect.left - count_surf.get_width() - 5
            
        screen.blit(count_surf, (text_x, self.rect.centery - count_surf.get_height() // 2))

# ------------------------------------
# 3. Bubble é¡åˆ¥ (æ³¡æ³¡ç‰©ä»¶)
# ------------------------------------
class Bubble(pygame.sprite.Sprite):
    def __init__(self, color, row, col, is_static=False):
        super().__init__()
        self.color = color
        self.row = row
        self.col = col
        self.is_static = is_static
        self.is_falling = False
        self.gravity = GRAVITY
        self.fall_speed = 0

        # èƒ½é‡ç¯„åœ (3, 7)
        self.energy = random.randint(3, 7) 

        self.is_bomb = (color == BOMB_COLOR)
        self.is_rainbow = (color == RAINBOW_COLOR)
        self.is_shifter = (color == SHIFTER_COLOR)
        self.shifter_timer = 0 

        self.rect = pygame.Rect(0, 0, BUBBLE_DIAMETER, BUBBLE_DIAMETER)
        self.vel_x = 0
        self.vel_y = 0
        self.update_position()

    def update_position(self):
        """è¨ˆç®—æ³¡æ³¡çš„åƒç´ ä½ç½® (å¯¦ç¾èœ‚å·¢ç‹€ç¶²æ ¼)"""
        x_offset = 0 if self.row % 2 == 0 else BUBBLE_RADIUS
        
        # æ³¨æ„ï¼šé€™è£¡åªè¨ˆç®—ç¶²æ ¼å…§ç›¸å°ä½ç½®ï¼Œå¯¦éš›ç¹ªè£½åœ¨ Game.draw_game_elements ä¸­å¯èƒ½æœƒæœ‰åç§»
        x = self.col * BUBBLE_DIAMETER + x_offset + BUBBLE_RADIUS
        y = self.row * int(BUBBLE_DIAMETER * 0.866) + BUBBLE_RADIUS
        
        self.rect.center = (x, y)
        self.center = self.rect.center

    def draw(self, screen):
        """ç¹ªè£½æ³¡æ³¡ï¼ŒåŒ…å«ç‰¹æ®Šæ¨™è¨˜ã€å‹•æ…‹é¡è‰²å’Œèƒ½é‡å€¼"""
        draw_color = self.color
        center_x, center_y = self.center
        R = BUBBLE_RADIUS
        
        if self.is_shifter:
            time_ms = pygame.time.get_ticks()
            current_index = (time_ms // 100) % len(COLOR_OPTIONS)
            draw_color = COLOR_OPTIONS[current_index]
            
        # 1. ç¹ªè£½ä¸»é«”
        pygame.draw.circle(screen, draw_color, self.center, R)
        
        # 2. ç¹ªè£½å…‰å½±æ•ˆæœ
        highlight_radius = R // 2
        highlight_center = (center_x - R // 3, center_y - R // 3)
        pygame.draw.circle(screen, WHITE, highlight_center, highlight_radius, 0)
        pygame.draw.circle(screen, WHITE, highlight_center, R // 5, 0)
            
        # 3. ç¹ªè£½ç‰¹æ®Šæ¨™è¨˜
        if self.is_bomb:
            pygame.draw.line(screen, BLACK, (center_x - 10, center_y - 10), (center_x + 10, center_y + 10), 3)
            pygame.draw.line(screen, BLACK, (center_x + 10, center_y - 10), (center_x - 10, center_y + 10), 3)
        elif self.is_rainbow:
            pygame.draw.circle(screen, WHITE, self.center, R // 3)
        elif self.is_shifter:
            font = pygame.font.SysFont('Arial', R + 5, bold=True)
            text_surf = font.render("?", True, BLACK)
            text_rect = text_surf.get_rect(center=self.center)
            screen.blit(text_surf, text_rect)
            
        # 4. ç¹ªè£½èƒ½é‡å€¼ 
        if not self.is_bomb and not self.is_rainbow and not self.is_shifter and self.energy > 0:
            font = pygame.font.SysFont('Arial', R - 5, bold=True)
            text_color = BLACK if sum(self.color) > 300 else WHITE 
            text_surf = font.render(str(self.energy), True, text_color)
            text_rect = text_surf.get_rect(center=self.center)
            screen.blit(text_surf, text_rect)


# ------------------------------------
# 4. Game é¡åˆ¥ï¼šéŠæˆ²ä¸»é‚è¼¯
# ------------------------------------
class Game:
    def __init__(self):
        pygame.init()
        self.screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
        pygame.display.set_caption("Pygame Bubble Shooter")
        self.clock = pygame.time.Clock()

        self.score_font = pygame.font.SysFont('Arial', 24)
        self.title_font = pygame.font.SysFont('Arial', 48, bold=True)
        self.button_font = pygame.font.SysFont('Arial', 32)
        
        self.current_state = GameState.MENU
        self.running = True

        # åª’é«”åˆå§‹åŒ–ï¼šè«‹ç¢ºä¿æ‚¨æœ‰ 'sounds/bg_music.mp3' å’Œ 'assets/' ä¸‹çš„åœ–ç‰‡
        self.music_path = os.path.join('sounds', 'bg_music.mp3') 
        self.background_image_path = os.path.join('assets', 'background.png')
        self.bomb_image_path = os.path.join('assets', 'bomb.png') 
        self.hammer_image_path = os.path.join('assets', 'hammer.jpg') 
        
        self.background_image = self._load_background_image()
        self.power_up_images = self._load_power_up_images() 
        
        self._load_and_play_music()

        # è®Šæ•¸åˆå§‹åŒ–
        self.score = 0
        self.shots_since_push = 0
        self.falling_bubbles = []
        self.GAME_TIME_LIMIT = 120
        self.time_left = self.GAME_TIME_LIMIT
        self.last_time_check = pygame.time.get_ticks()
        
        self.INITIAL_POWER_UP_COUNT = 2
        self.power_up_counts = {"BOMB": self.INITIAL_POWER_UP_COUNT, "HAMMER": self.INITIAL_POWER_UP_COUNT}
        self.power_up_objects = []
        self.hammer_mode = False
        self.notification_text = None
        self.notification_timer = 0
        
        self.ENERGY_BAR_MAX = ENERGY_BAR_MAX 
        self.current_energy = 0
        self.is_impact_ready = False
        
        self.is_fast_mode = False
        self.fast_mode_timer = 0
        self.FAST_MODE_DURATION = FAST_MODE_DURATION
        
        self.reset_game()
        
    # --- åª’é«”è™•ç†æ–¹æ³• (ç•¥) ---
    def _load_background_image(self):
        try:
            image = pygame.image.load(self.background_image_path).convert_alpha()
            return pygame.transform.scale(image, (SCREEN_WIDTH, SCREEN_HEIGHT))
        except pygame.error as e:
            print(f"ç„¡æ³•åŠ è¼‰èƒŒæ™¯åœ–ç‰‡ {self.background_image_path}: {e}")
            return None

    def _load_power_up_images(self):
        images = {}
        try:
            bomb_img = pygame.image.load(self.bomb_image_path).convert_alpha()
            images["BOMB"] = pygame.transform.scale(bomb_img, (40, 40))
            
            hammer_img = pygame.image.load(self.hammer_image_path).convert_alpha()
            images["HAMMER"] = pygame.transform.scale(hammer_img, (40, 40))
            
            return images
        except pygame.error as e:
            print(f"ç„¡æ³•åŠ è¼‰é“å…·åœ–ç‰‡ ({e})ã€‚è«‹ç¢ºèªæª”æ¡ˆè·¯å¾‘æ˜¯å¦æ­£ç¢º (assets/bomb.png, assets/hammer.jpg)ã€‚å°‡ä½¿ç”¨é è¨­æ–‡å­—æ¨™ç±¤ã€‚")
            return {}
            
    def _load_and_play_music(self):
        try:
            pygame.mixer.music.load(self.music_path)
            pygame.mixer.music.play(-1)
            pygame.mixer.music.set_volume(0.5)
        except pygame.error as e:
            print(f"ç„¡æ³•åŠ è¼‰æˆ–æ’­æ”¾éŸ³æ¨‚ {self.music_path}: {e}")
            self.music_path = None

    # --- éŠæˆ²é‡ç½®èˆ‡åˆå§‹åŒ–æ–¹æ³• (ç•¥) ---
    def reset_game(self):
        self.grid = []
        self.shooter_bubble = None
        self.next_bubble_color = None
        self.is_shooting = False
        self.score = 0
        self.shots_since_push = 0
        self.falling_bubbles = []
        self.time_left = self.GAME_TIME_LIMIT
        self.last_time_check = pygame.time.get_ticks()
        
        self.power_up_counts = {"BOMB": self.INITIAL_POWER_UP_COUNT, "HAMMER": self.INITIAL_POWER_UP_COUNT}
        self.hammer_mode = False
        self.notification_text = None
        
        self.current_energy = 0
        self.is_impact_ready = False
        self.is_fast_mode = False
        self.fast_mode_timer = 0
        
        self._setup_power_ups_ui()
        self._setup_grid()
        self.new_shooter_bubble()

    def _setup_power_ups_ui(self):
        self.power_up_objects = []
        positions = {
            "BOMB": SCREEN_WIDTH // 2 - 150,
            "HAMMER": SCREEN_WIDTH // 2 + 100
        }
        
        for type_name in ["BOMB", "HAMMER"]:
            x = positions[type_name]
            y = POWER_UP_AREA_Y
            rect = pygame.Rect(x, y, 50, 50)
            image = self.power_up_images.get(type_name) 
            power_up = PowerUp(type_name, rect, self.score_font, image) 
            self.power_up_objects.append(power_up)

    def _setup_grid(self):
        for r in range(ROWS):
            row_list = []
            for c in range(COLS):
                bubble = None
                if r < 5:
                    if r % 2 != 0 and c == COLS - 1:
                        pass
                    else:
                        rand = random.random()
                        color = random.choice(COLOR_OPTIONS[:4])
                        if rand < 0.02:
                             color = BOMB_COLOR
                        elif rand < 0.04:
                             color = RAINBOW_COLOR
                        elif rand < 0.06:
                             color = SHIFTER_COLOR
                        
                        bubble = Bubble(color, r, c, is_static=True) 
                row_list.append(bubble)
            self.grid.append(row_list)
            
    # --- å°„æ“Šèˆ‡ç¶²æ ¼æ“ä½œæ–¹æ³• (ç•¥) ---
    def new_shooter_bubble(self):
        if self.next_bubble_color is None:
            self.next_bubble_color = random.choice(COLOR_OPTIONS)
        
        color = self.next_bubble_color
        
        self.shooter_bubble = Bubble(color, -1, -1)
        self.shooter_bubble.rect.center = (SCREEN_WIDTH // 2, SHOOTER_Y)
        self.shooter_bubble.center = self.shooter_bubble.rect.center
        
        rand = random.random()
        if rand < 0.03:
            self.next_bubble_color = random.choice([BOMB_COLOR, RAINBOW_COLOR])
        else:
            self.next_bubble_color = random.choice(COLOR_OPTIONS)

    def swap_bubbles(self):
        if not self.is_shooting and self.shooter_bubble and self.next_bubble_color:
            current_color = self.shooter_bubble.color
            self.shooter_bubble.color = self.next_bubble_color
            self.next_bubble_color = current_color
            
            self.shooter_bubble.is_bomb = (self.shooter_bubble.color == BOMB_COLOR)
            self.shooter_bubble.is_rainbow = (self.shooter_bubble.color == RAINBOW_COLOR)
            self.shooter_bubble.is_shifter = (self.shooter_bubble.color == SHIFTER_COLOR)

    def get_neighbors(self, r, c):
        neighbors = []
        is_odd = r % 2 != 0

        neighbors.append((r - 1, c))      
        neighbors.append((r + 1, c))      
        neighbors.append((r, c - 1))      
        neighbors.append((r, c + 1))      

        if is_odd:
            neighbors.append((r - 1, c + 1))
            neighbors.append((r + 1, c + 1))
        else:
            neighbors.append((r - 1, c - 1))
            neighbors.append((r + 1, c - 1))
            
        return neighbors

    def get_nearest_grid_position(self, x, y):
        r = int(y / (BUBBLE_DIAMETER * 0.866))
        r = max(0, min(ROWS - 1, r))

        x_offset = BUBBLE_RADIUS if r % 2 != 0 else 0
        
        c = int((x - x_offset) / BUBBLE_DIAMETER)
        c = max(0, min(COLS - 1, c))

        return r, c

    # --- ç¢°æ’è™•ç†èˆ‡æ¶ˆé™¤é‚è¼¯ (ç•¥) ---
    def _attach_bubble_to_grid(self, bubble, r, c):
        bubble.row = r
        bubble.col = c
        bubble.is_static = True
        bubble.update_position()
        self.grid[r][c] = bubble

    def _resolve_collision(self, bubble, hit_top=False, target_bubble=None):
        r, c = -1, -1
        
        if target_bubble:
            r_target, c_target = target_bubble.row, target_bubble.col
            min_dist_sq = float('inf')
            
            for r_n, c_n in self.get_neighbors(r_target, c_target):
                if 0 <= r_n < ROWS and 0 <= c_n < COLS and self.grid[r_n][c_n] is None:
                    temp_bubble = Bubble(WHITE, r_n, c_n, is_static=False)
                    dist_sq = (bubble.center[0] - temp_bubble.center[0])**2 + \
                              (bubble.center[1] - temp_bubble.center[1])**2
                    
                    if dist_sq < min_dist_sq:
                        min_dist_sq = dist_sq
                        r, c = r_n, c_n
        
        elif hit_top:
            r, c = self.get_nearest_grid_position(bubble.center[0], BUBBLE_RADIUS + 1)
        
        r = max(0, min(ROWS - 1, r))
        c = max(0, min(COLS - 1, c))

        if self.grid[r][c] is None:
            self._handle_match_and_specials(bubble, r, c)
            self.shots_since_push += 1
            if self.shots_since_push >= PUSH_FREQUENCY:
                self.push_new_row()
                self.shots_since_push = 0
        else:
            pass 
            
        self.new_shooter_bubble()

    def _handle_match_and_specials(self, bubble, r, c):
        if bubble.is_bomb:
            self.trigger_bomb(r, c)
        
        else:
            self._attach_bubble_to_grid(bubble, r, c)
            target_color = bubble.color
            
            if bubble.is_rainbow:
                match_neighbor_color = None
                for r_n, c_n in self.get_neighbors(r, c):
                    if 0 <= r_n < ROWS and 0 <= c_n < COLS and self.grid[r_n][c_n]:
                        neighbor = self.grid[r_n][c_n]
                        if not (neighbor.is_rainbow or neighbor.is_bomb or neighbor.is_shifter):
                            match_neighbor_color = neighbor.color
                            break
                if match_neighbor_color:
                    target_color = match_neighbor_color
                    self.grid[r][c].color = target_color
            
            matches = self.check_for_matches(r, c, target_color)
            if self.clear_matches(matches):
                self.check_for_floating_bubbles()

    def check_for_matches(self, r, c, target_color):
        if self.grid[r][c] is None:
            return []
            
        queue = [(r, c)]
        visited = set([(r, c)])
        matched_bubbles = []

        while queue:
            curr_r, curr_c = queue.pop(0)
            matched_bubbles.append((curr_r, curr_c))

            for next_r, next_c in self.get_neighbors(curr_r, curr_c):
                if 0 <= next_r < ROWS and 0 <= next_c < COLS:
                    neighbor = self.grid[next_r][next_c]
                    
                    if neighbor and (next_r, next_c) not in visited:
                        is_match = (neighbor.color == target_color or neighbor.is_rainbow or neighbor.is_shifter)
                        
                        if is_match:
                            visited.add((next_r, next_c))
                            queue.append((next_r, next_c))
                            
        return matched_bubbles

    def clear_matches(self, matches):
        if len(matches) >= 3:
            cleared_count = 0
            total_energy_gained = 0
            
            for r, c in matches:
                bubble = self.grid[r][c]
                if bubble:
                    total_energy_gained += bubble.energy
                    
                    bubble.is_falling = True
                    bubble.is_static = False
                    self.falling_bubbles.append(bubble)
                    self.grid[r][c] = None
                    cleared_count += 1
            
            self.score += cleared_count * 10
            
            # æ›´æ–°èƒ½é‡æ¢
            if total_energy_gained > 0:
                self.current_energy += total_energy_gained
                self.current_energy = min(self.current_energy, self.ENERGY_BAR_MAX)
                
                if self.current_energy >= self.ENERGY_BAR_MAX and not self.is_impact_ready:
                    self.is_impact_ready = True
                    self.notification_text = "âœ¨ èƒ½é‡è¡æ“Šå°±ç·’ï¼(æŒ‰ E éµ)"
                    self.notification_timer = pygame.time.get_ticks()

            
            if cleared_count >= 5 and random.random() < 0.20:
                power_up_type = random.choice(["BOMB", "HAMMER"])
                self.spawn_power_up(power_up_type)
                
            return cleared_count > 0
        return False
        
    def check_for_floating_bubbles(self):
        visited = set()
        queue = []
        for c in range(COLS):
            if self.grid[0][c] is not None:
                queue.append((0, c))
                visited.add((0, c))
        
        while queue:
            curr_r, curr_c = queue.pop(0)
            for next_r, next_c in self.get_neighbors(curr_r, curr_c):
                if 0 <= next_r < ROWS and 0 <= next_c < COLS and (next_r, next_c) not in visited:
                    neighbor = self.grid[next_r][next_c]
                    if neighbor:
                        visited.add((next_r, next_c))
                        queue.append((next_r, next_c))
                        
        dropped_count = 0
        for r in range(ROWS):
            for c in range(COLS):
                if self.grid[r][c] is not None and (r, c) not in visited:
                    bubble = self.grid[r][c]
                    bubble.is_falling = True
                    bubble.is_static = False
                    self.falling_bubbles.append(bubble)
                    self.grid[r][c] = None
                    dropped_count += 1
        
        if dropped_count > 0:
            self.score += dropped_count * 50

    # --- èƒ½é‡èšåˆæ¨¡å¼æ–¹æ³• ---
    def trigger_energy_impact(self):
        if not self.is_impact_ready or self.current_state != GameState.PLAYING:
            return

        detonation_count = self.current_energy // 10 
        detonation_count = max(5, min(detonation_count, 50))

        self.current_energy = 0
        self.is_impact_ready = False
        
        possible_targets = []
        for r in range(ROWS):
            for c in range(COLS):
                if self.grid[r][c] is not None:
                    possible_targets.append((r, c))
                    
        targets_to_detonate = random.sample(possible_targets, min(detonation_count, len(possible_targets)))
        
        detonated_score = 0
        for r, c in targets_to_detonate:
            bubble = self.grid[r][c]
            if bubble:
                bubble.is_falling = True
                self.falling_bubbles.append(bubble)
                self.grid[r][c] = None
                detonated_score += ENERGY_IMPACT_BUBBLE_SCORE
                
        self.score += detonated_score
        
        if detonated_score > 0:
            # å•Ÿå‹•å¿«é€Ÿå°„æ“Šæ¨¡å¼
            self.is_fast_mode = True
            self.fast_mode_timer = pygame.time.get_ticks()
            
            # é¡¯ç¤ºé€šçŸ¥
            self.notification_text = f"ğŸ’¥ èƒ½é‡è¡æ“Šï¼å¿«é€Ÿæ¨¡å¼å•Ÿå‹• ({self.FAST_MODE_DURATION} ç§’)ï¼"
            self.notification_timer = pygame.time.get_ticks()
            self.check_for_floating_bubbles()

    # --- é“å…·èˆ‡å±æ©Ÿè™•ç† (ç•¥) ---
    def push_new_row(self):
        if any(self.grid[ROWS - 2][c] is not None for c in range(COLS)):
            self.current_state = GameState.GAMEOVER
            return

        for r in range(ROWS - 1, 0, -1):
            for c in range(COLS):
                if self.grid[r-1][c] is not None:
                    self.grid[r-1][c].row = r
                    self.grid[r-1][c].update_position()
                self.grid[r][c] = self.grid[r-1][c]

        possible_colors = [b.color for r_list in self.grid[1:] for b in r_list if b and b.color not in SPECIAL_COLORS]
        if not possible_colors:
             possible_colors = COLOR_OPTIONS[:4]
        
        new_row = []
        for c in range(COLS):
            rand = random.random()
            color = random.choice(possible_colors)
            if rand < 0.02: color = BOMB_COLOR
            elif rand < 0.04: color = RAINBOW_COLOR
            elif rand < 0.06: color = SHIFTER_COLOR
            
            new_bubble = Bubble(color, 0, c, is_static=True)
            new_row.append(new_bubble)
            
        self.grid[0] = new_row
        
    def trigger_bomb(self, r, c):
        bubbles_to_clear = set([(r, c)])
        for r_n, c_n in self.get_neighbors(r, c):
            if 0 <= r_n < ROWS and 0 <= c_n < COLS and self.grid[r_n][c_n]:
                bubbles_to_clear.add((r_n, c_n))
                
        cleared_any = False
        for r_clear, c_clear in bubbles_to_clear:
            bubble = self.grid[r_clear][c_clear]
            if bubble:
                bubble.is_falling = True
                self.falling_bubbles.append(bubble)
                self.grid[r_clear][c_clear] = None
                self.score += 20
                cleared_any = True
                
        if cleared_any:
            self.check_for_floating_bubbles()

    def spawn_power_up(self, power_up_type):
        self.power_up_counts[power_up_type] += 1
        self._setup_power_ups_ui()
        
        self.notification_text = f"ğŸ‰ ç²å¾— {power_up_type} é“å…·ï¼"
        self.notification_timer = pygame.time.get_ticks()

    def activate_power_up(self, type_name):
        if self.power_up_counts[type_name] > 0:
            if type_name == "BOMB":
                self.use_bomb_power_up()
                self.power_up_counts["BOMB"] -= 1
            elif type_name == "HAMMER":
                self.hammer_mode = True
            self._setup_power_ups_ui()

    def use_bomb_power_up(self, radius=3):
        center_r, center_c = ROWS // 3, COLS // 2
        cells_to_clear = set()
        
        for r_offset in range(-radius, radius + 1):
            for c_offset in range(-radius, radius + 1):
                r, c = center_r + r_offset, center_c + c_offset
                if 0 <= r < ROWS and 0 <= c < COLS:
                    cells_to_clear.add((r, c))

        for r, c in cells_to_clear:
            bubble = self.grid[r][c]
            if bubble:
                bubble.is_falling = True
                self.falling_bubbles.append(bubble)
                self.grid[r][c] = None
                self.score += 50
                
        self.check_for_floating_bubbles()

    def use_hammer(self, r, c):
        if self.power_up_counts["HAMMER"] > 0:
            bubble = self.grid[r][c]
            if bubble:
                bubble.is_falling = True
                self.falling_bubbles.append(bubble)
                self.grid[r][c] = None
                self.score += 30
                self.check_for_floating_bubbles()
            
            self.power_up_counts["HAMMER"] -= 1
            self.hammer_mode = False
            self._setup_power_ups_ui()

    # --- è¼¸å…¥è™•ç† (ç•¥) ---
    def handle_input(self):
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                self.running = False
            
            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_SPACE and self.current_state == GameState.PLAYING and not self.is_shooting:
                    self.swap_bubbles()
                elif event.key == pygame.K_p:
                    if self.current_state == GameState.PLAYING:
                        self.current_state = GameState.PAUSED
                        if self.music_path: pygame.mixer.music.pause()
                    elif self.current_state == GameState.PAUSED:
                        self.current_state = GameState.PLAYING
                        if self.music_path: pygame.mixer.music.unpause()
                elif event.key == pygame.K_e:
                    if self.is_impact_ready and self.current_state == GameState.PLAYING:
                        self.trigger_energy_impact()
            
            if event.type == pygame.MOUSEBUTTONDOWN:
                mouse_x, mouse_y = pygame.mouse.get_pos()
                
                if self.current_state == GameState.MENU:
                    self._handle_menu_click(mouse_x, mouse_y)
                elif self.current_state == GameState.GAMEOVER:
                    self._handle_gameover_click(mouse_x, mouse_y) 
                elif self.current_state == GameState.PLAYING:
                    self._handle_playing_click(mouse_x, mouse_y)

    def _handle_menu_click(self, x, y):
        start_button_rect = pygame.Rect(SCREEN_WIDTH // 2 - 100, SCREEN_HEIGHT // 2 - 50, 200, 60)
        quit_button_rect = pygame.Rect(SCREEN_WIDTH // 2 - 100, SCREEN_HEIGHT // 2 + 50, 200, 60)
        
        if start_button_rect.collidepoint(x, y):
            self.current_state = GameState.PLAYING
            self.reset_game()
        elif quit_button_rect.collidepoint(x, y):
            self.running = False

    def _handle_gameover_click(self, x, y):
        restart_button_rect = pygame.Rect(SCREEN_WIDTH // 2 - 100, SCREEN_HEIGHT // 2 + 50, 200, 60)
        if restart_button_rect.collidepoint(x, y):
            self.current_state = GameState.MENU
            self.reset_game() 

    def _handle_playing_click(self, x, y):
        
        if self.hammer_mode:
            r, c = self.get_nearest_grid_position(x, y)
            if 0 <= r < ROWS and 0 <= c < COLS and self.grid[r][c] is not None:
                self.use_hammer(r, c)
            else:
                self.hammer_mode = False 
            return
        
        for pu_obj in self.power_up_objects:
            if pu_obj.rect.collidepoint(x, y):
                self.activate_power_up(pu_obj.type)
                return

        if y < POWER_UP_AREA_Y and not self.is_shooting:
            start_x, start_y = self.shooter_bubble.center
            dx = x - start_x
            dy = y - start_y
            
            if dy < 0:
                dist = math.sqrt(dx**2 + dy**2)
                
                speed = FAST_SHOOT_SPEED if self.is_fast_mode else SHOOT_SPEED 
                
                self.shooter_bubble.vel_x = (dx / dist) * speed
                self.shooter_bubble.vel_y = (dy / dist) * speed
                self.is_shooting = True

    # --- éŠæˆ²ä¸»å¾ªç’°æ›´æ–° (ç•¥) ---
    def update(self):
        if self.current_state != GameState.PLAYING:
            return
            
        current_time = pygame.time.get_ticks()
        time_elapsed = (current_time - self.last_time_check) / 1000.0
        self.last_time_check = current_time
        
        if self.is_fast_mode:
            if (current_time - self.fast_mode_timer) / 1000.0 >= self.FAST_MODE_DURATION:
                self.is_fast_mode = False
                self.notification_text = "å¿«é€Ÿæ¨¡å¼çµæŸã€‚"
                self.notification_timer = pygame.time.get_ticks()
        
        self.time_left -= time_elapsed
        if self.time_left <= 0:
            self.time_left = 0
            self.current_state = GameState.GAMEOVER
            if self.music_path: pygame.mixer.music.stop()
            return

        for r in range(ROWS):
            for c in range(COLS):
                bubble = self.grid[r][c]
                if bubble and bubble.is_shifter:
                    bubble.shifter_timer += 1
                    if bubble.shifter_timer >= 100:
                        possible_colors = [b.color for r_list in self.grid for b in r_list if b and b.color not in SPECIAL_COLORS]
                        bubble.color = random.choice(possible_colors if possible_colors else COLOR_OPTIONS)
                        bubble.shifter_timer = 0
        
        if self.is_shooting:
            self.shooter_bubble.rect.x += self.shooter_bubble.vel_x
            self.shooter_bubble.rect.y += self.shooter_bubble.vel_y
            self.shooter_bubble.center = self.shooter_bubble.rect.center
            
            if self.shooter_bubble.rect.left <= 0 or self.shooter_bubble.rect.right >= SCREEN_WIDTH:
                self.shooter_bubble.vel_x *= -1
            
            if self.shooter_bubble.rect.top <= BUBBLE_RADIUS:
                self.is_shooting = False
                self._resolve_collision(self.shooter_bubble, hit_top=True)
                return

            for r in range(ROWS):
                for c in range(COLS):
                    target_bubble = self.grid[r][c]
                    if target_bubble:
                        distance = math.sqrt(
                            (self.shooter_bubble.center[0] - target_bubble.center[0])**2 +
                            (self.shooter_bubble.center[1] - target_bubble.center[1])**2
                        )
                        if distance < BUBBLE_DIAMETER - 1:
                            self.is_shooting = False
                            self._resolve_collision(self.shooter_bubble, target_bubble=target_bubble)
                            return
            
        new_falling_bubbles = []
        for bubble in self.falling_bubbles:
            bubble.fall_speed += bubble.gravity
            bubble.rect.y += bubble.fall_speed
            bubble.center = bubble.rect.center
            
            if bubble.rect.top < SCREEN_HEIGHT:
                new_falling_bubbles.append(bubble)
        
        self.falling_bubbles = new_falling_bubbles

    # --- ç¹ªåœ–æ–¹æ³• (ä¿®æ­£ç„æº–ç·šå’Œ HUD) ---
    def draw_menu(self):
        self.screen.fill(WHITE)
        title_surf = self.title_font.render("Bubble Shooter Game", True, BLACK)
        title_rect = title_surf.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 - 150))
        self.screen.blit(title_surf, title_rect)

        start_rect = pygame.Rect(SCREEN_WIDTH // 2 - 100, SCREEN_HEIGHT // 2 - 50, 200, 60)
        pygame.draw.rect(self.screen, (70, 70, 200), start_rect, border_radius=10) 
        start_text = self.button_font.render("START GAME", True, WHITE) 
        self.screen.blit(start_text, start_text.get_rect(center=start_rect.center))

        quit_rect = pygame.Rect(SCREEN_WIDTH // 2 - 100, SCREEN_HEIGHT // 2 + 50, 200, 60)
        pygame.draw.rect(self.screen, (200, 50, 50), quit_rect, border_radius=10) 
        quit_text = self.button_font.render("QUIT GAME", True, WHITE) 
        self.screen.blit(quit_text, quit_text.get_rect(center=quit_rect.center))

    def draw_game_elements(self):
        
        # 1. ç¹ªè£½èƒŒæ™¯
        if self.current_state != GameState.GAMEOVER:
            if self.background_image:
                self.screen.blit(self.background_image, (0, 0))
            else:
                self.draw_procedural_background() 

        # 2. ç¹ªè£½ç¶²æ ¼å’Œæ‰è½ä¸­çš„æ³¡æ³¡
        for r in range(ROWS):
            for c in range(COLS):
                if self.grid[r][c]:
                    self.grid[r][c].draw(self.screen)
        for bubble in self.falling_bubbles:
            bubble.draw(self.screen)
            
        # 3. ç¹ªè£½ HUD å€åŸŸèƒŒæ™¯
        HUD_HEIGHT = 70
        hud_surface = pygame.Surface((SCREEN_WIDTH, HUD_HEIGHT), pygame.SRCALPHA)
        hud_surface.fill(HUD_BG_COLOR)
        self.screen.blit(hud_surface, (0, 0))
        
        Y_START = 5
        
        # --- åˆ†æ•¸ã€æ¨æ“ ã€æ™‚é–“ (ç¬¬ä¸€è¡Œ) ---
        score_text = self.score_font.render(f"Score: {self.score}", True, BLACK)
        self.screen.blit(score_text, (10, Y_START))
        push_text = self.score_font.render(f"Shots to Push: {PUSH_FREQUENCY - self.shots_since_push}", True, BLACK)
        self.screen.blit(push_text, (SCREEN_WIDTH - push_text.get_width() - 10, Y_START))
        minutes = int(self.time_left) // 60
        seconds = int(self.time_left) % 60
        time_text = self.score_font.render(f"Time Left: {minutes:02d}:{seconds:02d}", True, BLACK)
        self.screen.blit(time_text, (SCREEN_WIDTH // 2 - time_text.get_width() // 2, Y_START))
        
        # --- èƒ½é‡æ¢ (ç¬¬äºŒè¡Œ) ---
        bar_width = 200
        bar_height = 20
        bar_x = SCREEN_WIDTH // 2 - bar_width // 2
        bar_y = Y_START + 30 
        
        pygame.draw.rect(self.screen, (100, 100, 100), (bar_x, bar_y, bar_width, bar_height), border_radius=5)
        fill_width = (self.current_energy / self.ENERGY_BAR_MAX) * bar_width
        fill_color = ENERGY_COLOR if not self.is_impact_ready else FAST_MODE_COLOR 
        pygame.draw.rect(self.screen, fill_color, (bar_x, bar_y, fill_width, bar_height), border_radius=5)
        
        energy_label = "ENERGY READY! (E)" if self.is_impact_ready else f"ENERGY: {self.current_energy}/{self.ENERGY_BAR_MAX}"
        energy_color = BLACK if not self.is_impact_ready else RED 
        energy_text = self.score_font.render(energy_label, True, energy_color)
        energy_rect = energy_text.get_rect(center=(bar_x + bar_width // 2, bar_y + bar_height // 2))
        self.screen.blit(energy_text, energy_rect)
        
        # 4. ç¹ªè£½ç™¼å°„æ³¡æ³¡èˆ‡é è¦½
        if self.shooter_bubble:
            self.shooter_bubble.draw(self.screen)
        next_pos = (SCREEN_WIDTH // 2 + 50, SHOOTER_Y)
        pygame.draw.circle(self.screen, BLACK, next_pos, BUBBLE_RADIUS // 2 + 5, 2) 
        pygame.draw.circle(self.screen, self.next_bubble_color, next_pos, BUBBLE_RADIUS // 2)

        # 5. ç¹ªè£½å¯æ„›çš„é»ç‹€ç™¼å°„æŒ‡ç¤ºå™¨ (ç„æº–ç·š)
        if not self.is_shooting and not self.hammer_mode:
            mouse_x, mouse_y = pygame.mouse.get_pos()
            
            # ç™¼å°„å™¨æ³¡æ³¡çš„ä¸­å¿ƒé»
            start_x, start_y = self.shooter_bubble.center 
            
            # åªæœ‰ç•¶æ»‘é¼ åœ¨ç™¼å°„é»ä¸Šæ–¹æ™‚æ‰ç¹ªè£½
            if mouse_y < start_y:
                
                # ç„æº–ç·šçš„é¡è‰²ä½¿ç”¨ç•¶å‰ç™¼å°„æ³¡æ³¡çš„é¡è‰²
                line_color = self.shooter_bubble.color 
                dot_radius = 3       # å°åœ“é»çš„åŠå¾‘
                dot_spacing = 15     # é»èˆ‡é»ä¹‹é–“çš„é–“éš” (æ±ºå®šè™›ç·šçš„ç–å¯†)

                dx = mouse_x - start_x
                dy = mouse_y - start_y
                dist = math.sqrt(dx**2 + dy**2) # è¨ˆç®—æ»‘é¼ åˆ°ç™¼å°„é»çš„è·é›¢

                if dist > 0:
                    # è¨ˆç®—å–®ä½å‘é‡ (æ–¹å‘)
                    unit_x = dx / dist
                    unit_y = dy / dist
                    
                    # æ²¿è‘—å‘é‡æ–¹å‘ç¹ªè£½é»
                    draw_dist_limit = min(dist, 400) # é™åˆ¶æœ€é•·ç¹ªè£½è·é›¢
                    
                    for d in range(0, int(draw_dist_limit), dot_spacing):
                        dot_x = start_x + unit_x * d
                        dot_y = start_y + unit_y * d
                        
                        # ç¹ªè£½å°åœ“é» (æ¨¡ä»¿æˆªåœ–ä¸­çš„æ³¡æ³¡)
                        pygame.draw.circle(self.screen, line_color, (int(dot_x), int(dot_y)), dot_radius) 
                        
                        # ç¹ªè£½å°åœ“é»é‚Šç·£ (å¢åŠ å¯æ„›æ„Ÿ)
                        pygame.draw.circle(self.screen, BLACK, (int(dot_x), int(dot_y)), dot_radius + 1, 1)


        # 6. ç¹ªè£½é“å…·æ¬„ä½èˆ‡æç¤º
        pygame.draw.line(self.screen, BLACK, (0, POWER_UP_AREA_Y - 10), (SCREEN_WIDTH, POWER_UP_AREA_Y - 10), 1)
        for pu_obj in self.power_up_objects:
            pu_obj.draw(self.screen, self.power_up_counts[pu_obj.type])
            
        key_hints = "SPACE to SWAP | P to PAUSE"
        if self.is_impact_ready:
            key_hints += " | E for IMPACT (Ready!)"
        
        if self.is_fast_mode:
            fast_text = self.title_font.render("ğŸš€ FAST MODE! ğŸš€", True, (255, 0, 0))
            self.screen.blit(fast_text, fast_text.get_rect(center=(SCREEN_WIDTH // 2, 120)))

        swap_text = self.score_font.render(key_hints, True, BLACK)
        self.screen.blit(swap_text, (SCREEN_WIDTH // 2 - swap_text.get_width() // 2, SCREEN_HEIGHT - 30))

        if self.hammer_mode:
            hammer_text = self.score_font.render("ğŸ”¨ HAMMER MODE: Click a bubble to REMOVE it. ğŸ”¨", True, (255, 165, 0))
            self.screen.blit(hammer_text, (SCREEN_WIDTH // 2 - hammer_text.get_width() // 2, POWER_UP_AREA_Y + 60))

        # ç¹ªè£½é“å…·/èƒ½é‡ç²å¾—é€šçŸ¥
        if self.notification_text:
            time_elapsed = pygame.time.get_ticks() - self.notification_timer
            if time_elapsed < 2000:
                notif_surf = self.title_font.render(self.notification_text, True, BLACK) 
                notif_rect = notif_surf.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2))
                notif_bg = pygame.Surface(notif_rect.inflate(20, 10).size, pygame.SRCALPHA)
                notif_bg.fill((255, 255, 255, 180))
                self.screen.blit(notif_bg, notif_rect.inflate(20, 10).topleft)
                
                self.screen.blit(notif_surf, notif_rect)

    def draw_procedural_background(self):
        LIGHT_BG = (255, 255, 255) 
        DARK_BG = (255, 230, 200) 
        for y in range(SCREEN_HEIGHT):
            ratio = y / SCREEN_HEIGHT
            r = int(DARK_BG[0] + (LIGHT_BG[0] - DARK_BG[0]) * ratio)
            g = int(DARK_BG[1] + (LIGHT_BG[1] - DARK_BG[1]) * ratio)
            b = int(DARK_BG[2] + (LIGHT_BG[2] - DARK_BG[2]) * ratio)
            color = (r, g, b)
            pygame.draw.line(self.screen, color, (0, y), (SCREEN_WIDTH, y))

    def draw_gameover_screen(self):
        self.screen.fill(WHITE)
        gameover_text = self.title_font.render("GAME OVER", True, BLACK)
        text_rect = gameover_text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 - 100))
        self.screen.blit(gameover_text, text_rect)

        score_text = self.score_font.render(f"Final Score: {self.score}", True, BLACK)
        score_rect = score_text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 - 30))
        self.screen.blit(score_text, score_rect)
        
        restart_rect = pygame.Rect(SCREEN_WIDTH // 2 - 100, SCREEN_HEIGHT // 2 + 50, 200, 60)
        pygame.draw.rect(self.screen, (70, 70, 200), restart_rect, border_radius=10) 
        restart_text = self.button_font.render("BACK TO MENU", True, WHITE)
        self.screen.blit(restart_text, restart_text.get_rect(center=restart_rect.center))        
        
    def draw(self):
        if self.current_state == GameState.MENU:
            self.draw_menu()
        elif self.current_state == GameState.PLAYING or self.current_state == GameState.PAUSED:
            self.draw_game_elements()
            if self.current_state == GameState.PAUSED:
                pause_surf = self.title_font.render("æš«åœä¸­", True, BLACK) 
                self.screen.blit(pause_surf, pause_surf.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2)))
        elif self.current_state == GameState.GAMEOVER:
            self.draw_gameover_screen()

        pygame.display.flip()

    def run(self):
        while self.running:
            self.handle_input()
            self.update()
            self.draw()
            self.clock.tick(FPS)
        
        pygame.quit()
        sys.exit()

if __name__ == '__main__':
    game = Game()
    game.run()
